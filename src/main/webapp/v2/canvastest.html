<html lang="de">
<head>
    <title>Canvas</title>
    <style>
        body {
            background: #333;
        }

        .canvas {
            cursor: crosshair;
        }
    </style>
</head>
<body>
<canvas class="canvas" width="" height="" id="canvas"></canvas>
<script>
    function int2color(num) {
        return {
            a: num >> 24 & 0xFF,
            b: num >> 16 & 0xFF,
            g: num >> 8 & 0xFF,
            r: num & 0xFF
        };
    }

    function color2int(r, g, b, a) {
        return (a << 24) | (b << 16) | (g << 8) | r;
    }

    function distSq(x1, x2, y1, y2) {
        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    }

    function crystallize(imageData, width, height) {
        // Prepare crystallize
        var cells = 60;
        var cellWidth = width / cells;
        var cellHeight = height / cells;

        var xs = [];
        var ys = [];

        // Generate cells
        for (var y=0; y < cells; y++) {
            for (var x=0; x < cells; x++) {
                xs[y * cells + x] = Math.round(x * cellWidth + (Math.random() * cellWidth));
                ys[y * cells + x] = Math.round(y * cellHeight + (Math.random() * cellHeight));
            }
        }

        // Draw
        for (var a=0; a < height; a++) {
            for (var b=0; b < width; b++) {
                var currentCellX = Math.round(Math.min(Math.floor(b / cellWidth), cells - 1));
                var currentCellY = Math.round(Math.min(Math.floor(a / cellHeight), cells - 1));

                var nearestPoint = currentCellY * cells + currentCellX;

                var displacements = [
                    nearestPoint - cells - 1,
                    nearestPoint - cells,
                    nearestPoint - cells + 1,
                    nearestPoint - 1,
                    nearestPoint,
                    nearestPoint + 1,
                    nearestPoint + cells - 1,
                    nearestPoint + cells,
                    nearestPoint + cells + 1
                ];

                var adjacentPoints = [];
                for (var i=0; i < displacements.length; i++) {
                    var it = displacements[i];
                    if (it >= 0 && it <= xs.length - 1) {
                        adjacentPoints.push(it);
                    }
                }

                var n = 0;
                for (var j=0; j < adjacentPoints.length; j++) {
                    var jt = adjacentPoints[j];
                    if (distSq(xs[jt], b, ys[jt], a) < distSq(xs[n], b, ys[n], a)) n = jt
                }

                imageData[a * width + b] = imageData[ys[n] * width + xs[n]];
            }
        }
    }

    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    var originalImg = new Image();
    var crystalImg = new Image();
    var imageData;

    (function () {
        originalImg.onload = function() {
            init(this);
        };
        originalImg.src = 'demo.png';
    })();

    function drawBuffer(buffer) {
        imageData.data.set(buffer);
        ctx.putImageData(imageData, 0, 0);
    }

    function init(_this) {
        canvas.width = _this.width;
        canvas.height = _this.height;

        var canvasWidth  = canvas.width;
        var canvasHeight = canvas.height;

        ctx.drawImage(originalImg, 0, 0);

        imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);

        // Prepare original image buffer
        var originalBuf = new ArrayBuffer(imageData.data.length);
        var originalImage = new Uint8ClampedArray(originalBuf);
        var originalImage32 = new Uint32Array(originalBuf);

        for (var i=0; i < imageData.data.length; i++) {
            originalImage[i] = imageData.data[i];
        }

        // Prepare crystallized image buffer
        var crystalBuf = new ArrayBuffer(imageData.data.length);
        var crystalImage = new Uint8ClampedArray(crystalBuf);
        var crystalImage32 = new Uint32Array(crystalBuf);

        for (var j=0; j < imageData.data.length; j++) {
            crystalImage[j] = imageData.data[j];
        }

        crystallize(crystalImage32, canvasWidth, canvasHeight);

        // Prepare spare image
        drawBuffer(crystalImage);
        crystalImg.src = canvas.toDataURL();
        drawBuffer(originalImage);

        // Bind mousedown event
        var isDrag = false;
        canvas.addEventListener('mousedown', function () {
            isDrag = true;
        });
        canvas.addEventListener('mouseup', function () {
            isDrag = false;
        });
        canvas.addEventListener('mousemove', function (e) {
            if (!isDrag) {
                return;
            }

            var x = e.offsetX;
            var y = e.offsetY;

            ctx.drawImage(e.shiftKey? originalImg : crystalImg, x - 10, y - 10, 20, 20, x - 10, y - 10, 20, 20);
        });
    }

    // for (var y = 0; y < canvasHeight; ++y) {
    //     for (var x = 0; x < canvasWidth; ++x) {
    //         var color = getColor(originalImage32[y * canvasWidth + x]);
    //
    //         crystalImage32[y * canvasWidth + x] =
    //             (color.a << 24) |
    //             (color.b << 16) |
    //             (color.g <<  8) |
    //             color.r;
    //     }
    // }

    // imageData.data.set(originalImage);
    // ctx.putImageData(imageData, 0, 0);
</script>

</body>
</html>
